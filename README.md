# Secret Communication in Multimedia Forensics Using Image Steganography

Secret Communication program is an image and message encryption/decryption tool. It uses the SHA-256 hashing algorithm to store and compare passwords, and bitwise XOR encryption to encrypt both the image and message.

## How it works

The program takes in an image file, a secret message, and a password from the user. It then converts the image to grayscale, prompts the user for a password to encrypt the image, and uses the hashed version of this password to encrypt the image using bitwise XOR. The program then prompts the user to enter a password to encrypt the secret message, and uses the hashed version of this password to encrypt the message using bitwise XOR. The encrypted message and image are then saved to files.

![Hashing Algorithm](https://sectigostore.com/blog/wp-content/uploads/2022/04/hash-function-example.png)

The program then takes the encrypted image file and secret message file and combines them using bitwise XOR. The result is a single file with the secret message hidden within the image. The file can then be shared with someone who knows the password used to encrypt the message and image, allowing them to decrypt the message and view the original image.

![XOR Emcryption Keys](https://www.101computing.net/wp/wp-content/uploads/xor-encryption-keys.png)

To decrypt the message, the program prompts the user for the password used to encrypt the message and the password used to encrypt the image, hashes both passwords using SHA-256, and uses the hashed version of the password to decrypt the message and image using bitwise XOR.

**Step-by-Step Process:**

- Prompts the user to enter a password.
- Computes the SHA-256 hash of the user password.
- Reads in the user input image file and converts it to grayscale.
- Reads in the user secret message from a file.
- Prompts the user to enter a password to encrypt the image.
- Computes the SHA-256 hash of the image password and stores it in a file.
- Encrypts the secret message using the image password.
- Encrypts the input image using the hashed image password.
- Writes the encrypted message to a file and saves the encrypted image to a file.
- Prompts the user to enter the password to decrypt the message.
- Computes the SHA-256 hash of the decryption password and compares it to the hashed decryption password used for encryption.
- Decrypts the message using the decryption password and displays it.
- Decrypts the image using the decryption password.
- Displays the decrypted image.

**Code:** [secret.cpp
](https://github.com/mariahrucker/Secret_Communication/blob/main/secret.cpp)

## Installation

To install the required libraries, use the following commands:

- For OpenCV: sudo apt-get install libopencv-dev
- For OpenSSL: sudo apt-get install libssl-dev

**The program has 5 files:**

**1. The `input.png` file is provided by the user as the container for the secret message to be hidden and encrypted within it.**

The user only needs to provide the image file and the secret message file to the program, and the program will handle the encryption process and output the resulting encrypted image file and encrypted message file. The encrypted message file can be given to another user who has the same program and password to decrypt the message hidden within the encrypted image.

**2. The user is required to provide a password to insert the secret message from the `secret_message.txt` file into the `input.png` image file.**

The password is then used to encrypt the image file. When the user wants to decrypt the image and retrieve the secret message, they will provide the same password they used to encrypt the image. The program will then use the same password to generate the same hash and use it to decrypt the image file, revealing the secret message.

The `secret_message.txt` is created by the user who writes their message inside it. The message is then encrypted and embedded.**

**3. The `encrypted_message.txt` file is automatically populated with the encrypted version of the secret message using the password and hash value.**

The content of the encrypted message file is automatically generated by the program during the encryption process, using the secret message file provided by the user as input. The user doesn't need to create or modify the encrypted message file manually.

**4. The `message_to_decrypt.txt` file contains the scrambled version of the encrypted message that the user needs to decrypt using the password from the `hash_password.txt` file.**

The `message_to_decrypt.txt` file is automatically generated by the program when the user runs the decryption process, and it contains the decrypted message extracted from the `encrypted_message.txt` file. The user doesn't need to provide or create this file manually.

**5. The `hash_password.txt` file is automatically generated and contains the hash value of the password entered by the user for encrypting the secret message.**

The password is not automatically populated in the `hash_password.txt` file. The `hash_password.txt` file contains the hashed version of the password that the user provided during the encryption process. This hashed password is then used during the decryption process to verify if the password entered by the user is correct.

## Usage

To use the program, follow these steps:

Ensure that the following libraries are installed: 
- iostream
- fstream
- string
- bitset
- opencv2/opencv.hpp
- openssl/sha.h
- openssl/evp.h

Compile the program using a C++ compiler.
Run the program in the terminal or command prompt.

Follow the on-screen prompts to encrypt/decrypt the image and message.

**Encrypting an image and message:**

```yaml
Please enter the password: mypassword
Enter a password to encrypt the image: myimagepassword
Enter the password to encrypt the message: mymessagepassword
Decrypted message: Hello World.
```

**Decrypting an image and message:**

```yaml
Please enter the password: mypassword
Enter the password to decrypt the message: mymessagepassword
Decrypted message: Hello World.
```

**The encryption and decryption process:**

**1. Prompt the user for a password and compute its SHA-256 hash.**

```c++
cout << "Please enter a password: ";
string password;
cin >> password;

unsigned char hashed_password[SHA256_DIGEST_LENGTH];
SHA256((const unsigned char*)password.c_str(), password.length(), hashed_password);
string hashed_password_str((const char*)hashed_password, SHA256_DIGEST_LENGTH);
```

**2. Read a hashed password from a file and compare it to the hash of the user's password. If they match, proceed to the next step; otherwise, exit the program.**

```c++
string stored_hashed_password;
ifstream infile("password.txt");
if (infile.is_open()) {
    getline(infile, stored_hashed_password);
    infile.close();
} else {
    cout << "Error: Unable to open password.txt file." << endl;
    return -1;
}

if (stored_hashed_password != hashed_password_str) {
    cout << "Error: Passwords do not match. Access denied." << endl;
    return -1;
}
```

**3. Read an image from a file and convert it to grayscale.**

```c++
Mat image = imread("input.jpg");
if (image.empty()) {
    cout << "Error: Unable to read input image." << endl;
    return -1;
}

Mat grayscale_image;
cvtColor(image, grayscale_image, COLOR_BGR2GRAY);
```

**4. Read a secret message from a file.**

```c++
string secret_message;
ifstream secret_file("secret_message.txt");
if (secret_file.is_open()) {
    getline(secret_file, secret_message);
    secret_file.close();
} else {
    cout << "Error: Unable to open secret_message.txt file." << endl;
    return -1;
}
```

**5. Prompt the user to enter a password to encrypt the image.**

```c++
cout << "Enter a password to encrypt the image: ";
string image_password;
cin >> image_password;
```

**6. Compute the SHA-256 hash of the image password and store it in a file.**

```c++
unsigned char hashed_image_password[SHA256_DIGEST_LENGTH];
SHA256((const unsigned char*)image_password.c_str(), image_password.length(), hashed_image_password);
string hashed_image_password_str((const char*)hashed_image_password, SHA256_DIGEST_LENGTH);

ofstream hashed_password_file("hashed_password.txt");
if (hashed_password_file.is_open()) {
    hashed_password_file << hashed_image_password_str;
    hashed_password_file.close();
} else {
    cout << "Error: Unable to open hashed_password.txt file." << endl;
    return -1;
}
```

**7. Encrypt the secret message using the image password and write it to a file.**

```c++
string encrypted_message;
int password_length = hashed_image_password_str.length();
for (int i = 0; i < secret_message.length(); i++) {
    encrypted_message += secret_message[i] ^ hashed_image_password_str[i % password_length];
}

ofstream encrypted_file("encrypted_message.txt");
if (encrypted_file.is_open()) {
    encrypted_file << encrypted_message;
    encrypted_file.close();
} else {
    cout << "Error: Unable to open encrypted_message.txt file." << endl;
    return -1;
}
```

**8. Encrypt the image using the hashed image password (XORing it with each byte of the password in sequence) and save it to a file.**

```c++
Mat encrypted_image;
for (int i = 0; i < grayscale_image.rows; i++) {
    for (int j = 0; j < grayscale_image.cols; j++) {
        encrypted_image.at<uchar>(i, j) = grayscale_image.at
 ```

Encrypts an image and a message using a password-based encryption scheme, and allows the user to decrypt the message using a decryption password. 
The program uses the OpenCV and OpenSSL libraries for image processing and cryptographic functions. 

**Example Image:**

![Star Wars](https://imgix.bustle.com/fatherly/2019/12/last-jedi-rise-of-skywalker-rey-kylo-luke.jpg?w=1200&h=630&fit=crop&crop=faces&fm=jpg)

## Test File: [test_secretCommunication.cpp](https://github.com/mariahrucker/Secret_Communication/blob/main/test_secretCommunication.cpp)

The test file includes two tests for each of the functions encrypt, decrypt, encode, and decode. 

The tests check if the functions correctly encrypt/decrypt or encode/decode the input string. If all tests pass, the program prints "All tests passed!" to the console.

```C++
#include <iostream>
#include <cassert>
#include "secret.h"

int main() {
    std::string input = "Hello, world!";
    std::string key = "password";
    
    // Test encryption and decryption
    std::string encrypted = encrypt(input, key);
    std::string decrypted = decrypt(encrypted, key);
    assert(input == decrypted);
    
    // Test encode and decode
    std::string encoded = encode(input);
    std::string decoded = decode(encoded);
    assert(input == decoded);
    
    std::cout << "All tests passed!" << std::endl;
    
    return 0;
}
```

## Security Considerations

The program has some security weaknesses, such as storing the hashed password in a file and allowing an attacker to brute-force the password. It also uses a simple encryption algorithm that can be easily broken, especially with a short or weak password. 

## Security Enhancements

1. **Salted hash function:** The current implementation uses SHA-256 to hash passwords. While SHA-256 is a secure hash function, it is vulnerable to dictionary attacks and brute-force attacks. To make it more secure, a salt can be added to the password before hashing it. A salt is a random string of characters that is appended to the password before hashing which makes it harder for attackers to use precomputed hash tables to crack the passwords.

2. **Secure password input mechanism:** The current implementation reads the password directly from the console using the cin function which is not a secure way of accepting passwords as it leaves them vulnerable to interception by keyloggers or other malware. A more secure approach is to use a password input mechanism that does not echo the characters on the screen and clears them from memory after use.

3. **Authenticated encryption:** The current implementation uses a simple XOR-based encryption scheme to encrypt the message and the image whcih is not a secure encryption scheme as it is vulnerable to known-plaintext attacks and chosen-plaintext attacks. A more secure approach is to use authenticated encryption such as AES-GCM or ChaCha20-Poly1305. Authenticated encryption provides both confidentiality and integrity protection for the encrypted data.

4. **Secure random number generator:** The current implementation uses the rand function to generate random numbers which is not a secure random number generator as it is predictable and can be easily guessed. A more secure approach is to use a cryptographically secure random number generator such as std::random_device or std::mt19937.

5. **Avoid hardcoding sensitive information:** The current implementation hardcodes the filenames of the input image, secret message file, hashed password file, and encrypted message file. Hardcoding sensitive information makes it easier for attackers to locate and access these files. A more secure approach is to store the filenames in a configuration file or environment variable.

6. **Validate input:** The current implementation does not validate the user input for the password and message that leaves it vulnerable to buffer overflow attacks and other input-based attacks. A more secure approach is to validate the input for length, format, and content.

7. **Limit access:** The current implementation does not limit access to the hashed password file, encrypted message file, and secret message file which makes it easier for attackers to access these files. A more secure approach is to limit access to these files by using appropriate file permissions and access controls.

## License

Licensed under the MIT License. See the LICENSE file for more information.

## Contributions

Contributions to this project are welcome! If you find a bug or want to suggest an improvement, please open an issue or a pull request on the GitHub repository.

## Credits

Created by Mariah Rucker.

## Contact

If you have any questions or concerns, please feel free to contact Mariah Rucker at mariahrucker@myyahoo.com.
